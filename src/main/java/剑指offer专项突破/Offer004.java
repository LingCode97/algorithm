package 剑指offer专项突破;

/**
 * @author lingbohang on 2022/6/9
 *
 * 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。
 *
 *
 *
 *  示例 1：
 *
 *
 * 输入：nums = [2,2,3,2]
 * 输出：3
 *
 *
 *  示例 2：
 *
 *
 * 输入：nums = [0,1,0,1,0,1,100]
 * 输出：100
 *
 *
 *
 *
 *  提示：
 *
 *
 *  1 <= nums.length <= 3 * 10⁴
 *  -2³¹ <= nums[i] <= 2³¹ - 1
 *  nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次
 *
 *
 *
 *
 *  进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
 *
 *
 *
 *  注意：本题与主站 137 题相同：https://leetcode-cn.com/problems/single-number-ii/
 *  Related Topics 位运算 数组 👍 77 👎 0
 */
public class Offer004 {
    /**
     * 思路：
     *     假设有这么4个数，其中三个数一样，我们以2进制的方式来看待
     *     1101
     *     1101
     *     1101
     *     1001
     *     让每位上的数字相加，注意是十进制方式的相加
     *     最终=4304，然后再让4303每一位数字除以3，余数就是只出现一次的数字的二进制形式，也就是1001
     *     由于Java int类型是32位的，为了得到十进制数的每位二进制数，我们可以依次往右移，跟1进行&运行
     *     也就是代码中的bit[i] += num>>(31-i)&1;如果i=0,num>>(31-i)&1就是最左边那一位二进制数，然后直接加到bie数组对应的位置
     * */
    public int singleNumber(int[] nums) {
        int[] bit = new int[32];
        for(int num:nums){
            for(int i=0;i<32;i++){
                //01101>>(4-2)=00011
                //00011&00001=1
                bit[i] += num>>(31-i)&1;
            }
        }
        int result = 0;
        for(int i=0;i<32;i++){
            //00000+1=00001
            //00010+1=00011
            result = (result<<1)+bit[i]%3;
        }
        return  result;
    }
}
